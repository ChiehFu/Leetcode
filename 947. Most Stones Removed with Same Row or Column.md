---
title: 947. Most Stones Removed with Same Row or Column
tags: Union find, medium
notebook: Leetcode
---

On a 2D plane, we place stones at some integer coordinate points.  Each coordinate point may have at most one stone.

Now, a move consists of removing a stone that shares a column or row with another stone on the grid.

What is the largest possible number of moves we can make?

 
```
Example 1:

Input: stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]
Output: 5
```
```
Example 2:

Input: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]
Output: 3
```
```
Example 3:

Input: stones = [[0,0]]
Output: 0
``` 

Note:

- 1 <= stones.length <= 1000
- 0 <= stones[i][j] < 10000

----------
Thoughts:
1. Stone sharing a same column or a same row will belong to a same group.
2. For each group of n stones, we at most can remove n - 1 stones since except for the last stone, every stone will at least share a row or a column with other stone.
3. For each stone, directly use the index from the input as the id for it in union find
4. The number of removal we can perform at most will be `total number of stones - number of parent` (for each of the group, there will be one stone can't be removed)

5. The greedy solution won't give a optimal (always pick the stone sharing the row or column with fewest nodes), as the example below:
```
. o . . .
. o . . .
. o x . .
. . o o o
. . . . .
If we solve the case by union find, will get the answer 7(total stone) - 1(number of parent of different groups) = 6

However, if we  greedly choose the one sharing a column or a row with the fewest nodes, i.e. the stone denoted as 'x'.
We will break the group into two, and thus there will be totally two parents for two groups and the final answer will get is 5 which is not optimal.
```

```c++
//Union Find 
//Time: < O(NlogN)
//Space: N

class Solution {
public:
    int removeStones(vector<vector<int>>& stones) {
        parent_.assign(stones.size(), 0);
        for (int i = 0; i < parent_.size(); i++) parent_[i] = i;
        unordered_map<int, vector<int>> sameCol, sameRow;
        for (int i = 0; i < stones.size(); i++) {
            // Push the index of the stone into the sameCol and sameRow hashmap
            sameCol[stones[i][0]].push_back(i);
            sameRow[stones[i][1]].push_back(i);
        }
        // For the stones having same column, union them togeter
        for (auto &it : sameCol) {
            for (int i = 0; i < it.second.size() - 1; i++) {
                unionNode(it.second[i], it.second[i + 1]);
            }
        }
        // For the stones having same rows, union them togeter
        for (auto &it : sameRow) {
            for (int i = 0; i < it.second.size() - 1; i++) {
                unionNode(it.second[i], it.second[i + 1]);
            }
        }
        int count = 0;
        // Count the parent of the group which will its own parent
        for (int i = 0; i < parent_.size(); i++) {
            if (parent_[i] == i) count++;
        }
        return stones.size() - count;
    }
    int find(int i) {
        return parent_[i] == i? i : parent_[i] = find(parent_[i]);
    }
    void unionNode(int a, int b) {
        parent_[find(a)] = find(b);
    }
private:
    vector<int> parent_;
};
```