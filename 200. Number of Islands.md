---
title: 200. Number of Islands
tags: Graph, DFS, Union find, medium
notebook: Leetcode
---

Given a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.
Example 1:

```
Input:
11110
11010
11000
00000

Output: 1
```

Example 2:
```
Input:
11000
11000
00100
00011

Output: 3
```

----------
Thoughts:
1. Union find:
    1. Iterate through the 2D array, if current position is a island.
       1. Increase the numebr of island by 1.
       2. Check if the right or the below is a island as well.
          1. If yes, get their parents.
          2. If their parents are different, mount one to another and reduce the total island by 1.
2. DFS:
   1. Iterate through the 2d array, if current is a island and has not been visited, do DFS from it and mark the island to be visited along the travsesal path.
   2. T number of island will be the total number of times we do DFS traversal.

    ```c++
    //Union Find 
    //Time: O(NlogN)
    //Space: O(N)

    class Solution {
    public:
        int numIslands(vector<vector<char>>& grid) {
            if (grid.empty() || grid[0].empty()) return 0;
            int m = grid.size(), n = grid[0].size();
            int island = 0;
            int dirs[2][2] = {{0, 1}, {1, 0}};
            parents_.assign(m * n, -1);
            
            for (int i = 0; i < m; i++) {
                for (int j = 0; j < n; j++) {
                    
                    if (grid[i][j] == '1') {
                        // count unit island
                        island++;
                        
                        for (int d = 0; d < 2; d++) {
                            int newI = i + dirs[d][0];
                            int newJ = j + dirs[d][1];
                            if (newI >= m || newJ >= n || grid[newI][newJ] != '1') continue;
                            int p1 = findParent(i * n + j);
                            int p2 = findParent(newI * n + newJ);
                            if (p1 != p2) {
                                parents_[p1] = p2;
                                // If one parent has been mounted to another, reduce the numebr of island by 1
                                island--;
                            }
                        }
                    }
                }
            }
            return island;
        }
        int findParent(int num) {
            if (parents_[num] == -1) return parents_[num] = num;
            else return parents_[num] == num? num : parents_[num] = findParent(parents_[num]);
        }
    private:
        vector<int> parents_;
    };
    ```

    ```c++
    //DFS / BFS
    //Time: O(N)
    //Space: O(N)

    class Solution {
    public:
        int numIslands(vector<vector<char>>& grid) {
            int num_of_island = 0;
            for (int i = 0; i < grid.size(); ++i) {
                for (int j = 0; j < grid[0].size(); ++j) {
                    if (grid[i][j] != '1') continue;
                    ++num_of_island;
                    dfs(grid, i, j);
                    //bfs(grid, i, j);
                }
            }
            return num_of_island;
        }
        
        void dfs(vector<vector<char>>& grid, int i, int j) {
            grid[i][j] = '0';
            
            for (auto &dir : dirs) {
                int next_i = i + dir[0];
                int next_j = j + dir[1];
                
                if (next_i < 0 || next_i >= grid.size() || next_j < 0 || next_j >= grid[0].size()) continue;
                if (grid[next_i][next_j] != '1') continue;
                
                dfs(grid, next_i, next_j);   
            }
        }
        void bfs(vector<vector<char>>& grid, int i, int j) {
            queue<pair<int, int>> q;
            q.push({i, j});
            grid[i][j] = '0';
            
            while (!q.empty()) {
                
                int size = q.size();
                int i = q.front().first;
                int j = q.front().second;
                q.pop();
                
                for (auto &dir : dirs) {
                    int next_i = i + dir[0];
                    int next_j = j + dir[1];

                    if (next_i < 0 || next_i >= grid.size() || next_j < 0 || next_j >= grid[0].size()) continue;
                    if (grid[next_i][next_j] != '1') continue;
                    
                    grid[next_i][next_j] = '0';
                    q.push({next_i, next_j});
                }
            }
        }
    private:
        vector<vector<int>> dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    };
    ```