---
title: 792. Number of Matching Subsequences
tags: medium, Binary Search
notebook: Leetcode
---

Given string S and a dictionary of words words, find the number of words[i] that is a subsequence of S.

Example :
```
Input: 
S = "abcde"
words = ["a", "bb", "acd", "ace"]
Output: 3
Explanation: There are three words in words that are a subsequence of S: "a", "acd", "ace".
```
Note:

- All words in words and S will only consists of lowercase letters.
- The length of S will be in the range of [1, 50000].
- The length of words will be in the range of [1, 5000].
- The length of words[i] will be in the range of [1, 50].

----------


```Java
//Time: O(MlogN), M = word.length(), N = S.length()
//Space: O(26 + M)

class Solution {
	private List<Integer>[] indicesByAlphabet;

	public int numMatchingSubseq(String S, String[] words) {
		indicesByAlphabet = new List[26];

		for (int index = 0; index < S.length(); ++index) {
			int alphabetIndex = S.charAt(index) - 'a';
			if (indicesByAlphabet[alphabetIndex] == null) {
				indicesByAlphabet[alphabetIndex] = new ArrayList<>();
			}
			indicesByAlphabet[alphabetIndex].add(index);
		}

		int numOfMatchingWords = 0;

		for (String word : words) {
			if (isSubsequence(word)) {
				++numOfMatchingWords;
			}
		}

		return numOfMatchingWords;
	}

	private boolean isSubsequence(String word) {
		int nextLeastIndex = 0;

		for (char c : word.toCharArray()) {
			int alphabetIndex = c - 'a';
			List<Integer> indices = indicesByAlphabet[alphabetIndex];

            if (indices == null) {
                return false;
            }

			int nextIndex =
					Collections.binarySearch(indices, nextLeastIndex);

			if (nextIndex < 0) {
				nextIndex = -nextIndex - 1;
			}

			if (nextIndex >= indices.size() ||
					indices.get(nextIndex) < nextLeastIndex) {
				return false;
			}

			nextLeastIndex = indices.get(nextIndex) + 1;
		}

		return true;
	}
}
```

```Java

class Solution {
	public int numMatchingSubseq(String S, String[] words) {
		int numOfMatchingWords = 0;
		List<int[]>[] waiting = new List[26];
		for (int i = 0; i < 26; ++i) {
			waiting[i] = new ArrayList<>();
		}

		for (int i = 0; i < words.length; ++i) {
			waiting[words[i].charAt(0) - 'a'].add(new int[] {i, 1});
		}

		for (char c : S.toCharArray()) {
			List<int[]> advance = new ArrayList<>(waiting[c - 'a']);
			waiting[c - 'a'].clear();

			for (int[] pair : advance) {
				if (pair[1] == words[pair[0]].length()) {
					++numOfMatchingWords;
				} else {
					int index = words[pair[0]].charAt(pair[1]) - 'a';
					waiting[index].add(new int[] {pair[0], pair[1] + 1});
				}
			}
		}
		return numOfMatchingWords;
	}
}
```