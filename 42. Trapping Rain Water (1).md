---
title: 42. Trapping Rain Water
tags: Two Pointers, Dynamic Programming, hard, Stack
notebook: Leetcode
---

Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.

![alt](https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png)

The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image!

Example:
```c++
Input: [0,1,0,2,1,0,1,3,2,1,2,1]
Output: 6
```

----------
Thoughts:

**3 Solutions:**
1. Two Pointers
    - Imagine we put this map into a big container, and we start to inject the water into the container, so the water level keep increases.
    - Since the map is enclosed by the left-most and the right-most bin, as the water level get higher than one side of the bin, water will start getting into the map, and filled the gap between bins.
    - Use two pointer to keep track of the left and right sides, and the left and right water level, each time, we pick the side with lower level so that water will flow in first.
    - Say the water will flow from left side `l` at the level `l_level`, we go forward to the bin next to left `l + 1` and see:
        1. If the bin with the height `h` is higher than the level `l_level`, next time, the water level for left side `l + 1` needs to be at least `h` so that it can flow in, update the `l_level = h`.
        2. Otherwise, if the bin is lower that `l_level`, water can be trapped, so add the area `l_level - height[l + 1]` to the answer.
        3. Move `l = l + 1`
    - This question can be generalized to 3D map, i.e. [407. Trapping Rain Water II](https://leetcode.com/problems/trapping-rain-water-ii/), however, given there are more than two sides we can pick to send the water each time, we need some container like priority queue to figure out where is the position with lowest water level efficiently.
    - In this question, there is only two sides, so use two pointers `l, r` and the level for left and right `l_level, r_level` will be sufficient.

    ```c++
    //Time:  O(N)
    //Space: O(1)

    class Solution {
    public:
        int trap(vector<int>& height) {
            int l = 0, r = height.size() - 1;
            int lMax = 0, rMax = 0;
            int area = 0;
            
            while (l < r) {
                if (height[l] < height[r]) {
                    lMax = max(lMax, height[l]);
                    area += lMax - height[l];
                    l++;
                } else {
                    rMax = max(rMax, height[r]);
                    area += rMax - height[r];
                    r--;
                }
            }
            
            return area;
        }
    };
    ```
2. Dynamic Programming
    - Think of the trapping water of each bin is determined by the walls on two sides, scan from left to right to find the left highest wall for each bin. 
    - Scan from right to left to search for the right highest wall for each bin, calculate the area for each bin by `min(left, right) - bottom`.
    ```c++
    //Time:  O(N)
    //Space: O(N)

    class Solution {
    public:
        int trap(vector<int>& height) {
            vector<int> left(height.size(), 0);
            int cur = 0;
            for (int i = 0; i < left.size(); i++) {
                cur = max(cur, height[i]);
                left[i] = cur;
            }
            cur = 0;
            int area = 0;
            for (int i = left.size() - 1; i >= 0; i--) {
                cur = max(cur, height[i]);
                area += min(cur, left[i]) - height[i];
            }
            
            return area;
        }
    };
    ```
3. Stack
    - Push the height with index into the stack as long as the current height is shorter  than the last in the stack. 
    - When current height higher than the last in the stack, means current will be a right boundary and stack.top() will be the middle, and we pop out the values from stack until stack.top() > middle, and stack.top() will be the left side, calculate the area by `(min(left, right) - middle) * (right_index - left_index - 1)`.
    ```c++
    //Time:  O(N)
    //Space: O(N)

    class Solution {
    public:
        int trap(vector<int>& height) {
            stack<pair<int, int>> s;
            int area = 0;
            for (int i = 0; i < height.size(); i++) {
                while (!s.empty() && height[i] > s.top().first) {
                    int bot = s.top().first;
                    while (!s.empty() && s.top().first <= bot) {
                        s.pop();
                    }
                    if (!s.empty()) {
                        area += (min(s.top().first, height[i]) - bot) * (i - s.top().second - 1);
                    }
                }
                s.push({height[i], i});
            }
            
            return area;
        }
    };
    ```