---
title: 85. Maximal Rectangle
tags: Dynamic Programming, hard, stack
notebook: Leetcode
---

Given a 2D binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area.

Example:
```
Input:
[
  ["1","0","1","0","0"],
  ["1","0","1","1","1"],
  ["1","1","1","1","1"],
  ["1","0","0","1","0"]
]
Output: 6
```

----------
Thoughtsï¼š 

**Solution 1: Dynamic Programming**
1. Every rectangle is decided by a width and height
2. For a 1D case, `[1,1,0,0,0,1]`, to calculate the width of the rectangle, for each `1` that can forms a rectangle, keep track of the left and right boundary of the rectangle it belongs to
   1. Scan from left to right to assign the left boundary for each `1`, the left array will end up being like `left[0,0,x,x,x,5]`, the boundary of `non-rectangle` is not important.
   2. Scan from right to left to assign the right boundary like `right[1,1,x,x,x,5]`
   3. Calculate the area that can formed by each `1` as `(right[i] - left[i]) * height[i] (in 1d case, height is 1)`
   4. keep track of the maximal rectangle
3. Expand from 1d case to 2d case, of which the height is not always 1 anymore
   ```
    For the example like [0,1,1,0,1]
                         [1,1,1,0,0]
    1. calculate the left/right/height row by row as 1d case
    2. Accumulate the height if there are consecutive `1` at same position in different rows
    3. When current 1 inherits the height from the 1 from the previous row at the same index(namely, height[i] = height[i-1] + 1), it will subject to the left right boundary of that 1 from the previous row as well
   ```
    ```c++
    //Time: O(MN)
    //Space: O(N)

    class Solution {
    public:
        int maximalRectangle(vector<vector<char>>& matrix) {
            if (matrix.empty() || matrix[0].empty()) return 0;
            int n = matrix[0].size();
            int area = 0;
            vector<int> left(n, 0), right(n, n), height(n, 0);
            for (int i = 0; i < matrix.size(); i++) {
                //left and height
                int l = 0;
                for (int j = 0; j < n; j++) {
                    if (matrix[i][j] == '1') {
                        // New left boundary can't be more left then the left boundary of the 1 in previous row if we need to inherit the height (if there is no 1, it left will be set to 0, i.e. will have zero effect on current's boundary)
                        left[j] = max(left[j], l);
                        height[j] += 1;
                    } else {
                        // If it's a 0, set the boundary to be 0 so that it won't affect the left boundary of the 1 in next row (as there is no height for that 1 to inherit)
                        left[j] = 0;
                        // Set the height to 0
                        height[j] = 0;
                        l = j + 1;
                    }
                }
                //height and total area
                int r = n - 1;
                for (int j = n - 1; j >= 0; j--) {
                    if (matrix[i][j] == '1') {
                        // Same concept as for the left boundary
                        right[j] = min(right[j], r);
                    } else {
                        // If it's a 0, set the boundary to be n so that it won't affect the right boundary of the 1 in next row (as there is no height for that 1 to inherit)
                        right[j] = n;
                        r = j - 1;
                    }
                    // calculate area
                    area = max(area, (right[j] - left[j] + 1) * height[j]);
                }
            }
            return area;
        }
    };

    ```

**Solution 2: Stack**
1. Solve it like the question [84. Largest Rectangle in Histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/)
2. See the row of the matrix as a row of histograms, where each `'1'` in the row represents a histogram with height `1` and width `1`.
3. Use `i` to iterate over the rows in matrix, 
   1. For each row `i`, we maintain a row of histograms `hits`, where `hist[j]` represent the histogram growing from row `i` upwards to row `0` at position `j` as long as `matrix[i][j]` == '1'.
   2. For example, 
        ```c++
        For the matrix below:
        [
            ["1","0","1","0","0"],
            ["1","0","1","1","1"],
            ["1","1","1","1","1"],
            ["1","0","0","1","0"]
        ]
        When we iterate to the row 0, the hist we can get will be:
        hist = [1, 0, 1, 0, 0]

        When we iterate to the row 3, the hist we can get will be:
        [hist = 3, 1, 3, 2, 2]

        When we iterate to the row 4, the hist we can get will be:
        hist = [4, 0, 0, 3, 0]

        hist[1] , hist[2], hist[4] are zero due to the fact that matrix[3][1], matrix[3][2], matrix[3][4] are '0', which stop us from growing the histogram from row 3 to row 0
        ```
4. At each iteration, solve the problems [84. Largest Rectangle in Histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/) for the `hist` array, and keep the maximal area.

```c++
//Time : O(N * (M + M)), N rows, M cols, O(M) for solving the sub-problem
//Space: O(M)

class Solution {
public:
    int maximalRectangle(vector<vector<char>>& matrix) {
        if (matrix.empty() || matrix[0].empty()) return 0;
        int n = matrix.size(), m = matrix[0].size();
        vector<int> hist(m, 0);
        int max_area = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {

                // Growing the height of the histogram if possible
                if (matrix[i][j] == '1') hist[j]++;
                else hist[j] = 0;
            }
            // Solve the histogram problem and keep the optimum
            max_area = max(max_area, largestRectangleArea(hist));
        }
        return max_area;
    }
    int largestRectangleArea(vector<int>& heights) {
        stack<int> s;
        int max_rec = 0;
        for (int i = 0; i < heights.size(); i++) {
            while (!s.empty() && heights[i] < heights[s.top()]) {
                int index = s.top(); s.pop();
                int dis = i - ((s.empty())? -1:s.top()) - 1;
                max_rec = max(max_rec, dis * heights[index]);
            }
            s.push(i);
        }
        while (!s.empty()) {
            int index = s.top(); s.pop();
            int dis = heights.size() - ((s.empty())? -1:s.top()) - 1;
            max_rec = max(max_rec, dis * heights[index]);
        }
        return max_rec;
    }
};

```
